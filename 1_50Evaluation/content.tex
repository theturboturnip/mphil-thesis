\documentclass[../thesis]{subfiles}
\begin{document}

\chapter{Evaluation\label{chap:eval}}
% This project has two main research outcomes: an implementation for a potential CHERI-RVV specification, and a set of hypotheses/conclusions that can inform future work on combining scalable vector models with CHERI.
% This chapter describes the testing process for the emulator and concludes by summarizing the conclusions from previous chapters.

\todomark{Rewrite intro}
\todomark{Upgrade subsection -> section}

\section{Testing the emulator}
In order to verify the correct behaviour of the emulator, a set of self-checking integration test C programs were constructed.
All the programs follow the same pattern: each test program contains multiple tests, which each initialize an environment, perform the action under test, and check the impact on the environment was correct.
The individual test results are combined into a 64-bit bit vector and written to a special I/O memory location.
A bit vector noting which tests were run is also written to I/O memory, because some compilers or architectures do not support all tests.

Four compilers are tested, described in detail in \cref{chap:software}.
They include a build of GCC with support for vector intrinsics (\cref{appx:building_rvv_gcc_toolchain}), a binary distribution of Clang/LLVM-13, a custom build of Clang/LLVM-15, and a custom build of CHERI-Clang (based on LLVM 13) with changes to support RVV.
32-bit and 64-bit non-CHERI architectures are tested, along with 64-bit CHERI in Capability and Integer modes (\cref{chap:bg:subsec:cheriencodingmode}).
This section describes the tests in more detail, and notes any limitations in the software stack that prevent testing under some compilers/architectures.

% \todomark{Note somewhere that GCC support isn't a priority as of Dec 2021 https://github.com/riscv-collab/riscv-gcc/issues/320}

\subsection{\code{hello\_world}}
\code{hello\_world} runs three small functions which calculate Fibonacci numbers and factorials, testing that the emulator can handle basic programming constructs like recursive functions.
Fibonacci is calculated in two ways: once with a simple recursive function, and once with \emph{memoization} where previous outputs are cached in a static array.
The tests compile on all compilers, and output the correct results on all architectures.
\begin{table}[h]
    \centering
    \CatchFileDef{\tablehelloworld}{1_50Evaluation/data/hello_world_rows.tex}{}
    \begin{tabular}{rcccccc}
    \tablehelloworld
    \end{tabular}
    \caption{\code{hello\_world} results --- Basic program tests}\label{tab:fullresults:helloworld}
\end{table}


\subsection{\code{vector\_memcpy}}
\code{vector\_memcpy} is generated from a Python script, and consists of fifty-seven tests of different vector memory access archetypes under various configurations (\cref{tab:vectormemcpyschemes}).
Each of the nine test schemes are replicated for multiple \code{vtype} values, such that each individual LMUL and SEW value is tested.
These tests are run under \emph{harnesses}, which provide setup and self-checking code for common cases:
The Vanilla harness tests a simple \code{memcpy} between two arrays;
Masked tests that every other element is copied, not all of them;
Segmented tests a \code{memcpy} into four separate output arrays, each a different field of a four-field structure.
There is also a special test for fault-only-first: FoF loads are performed at the edge of mapped memory, and the test verifies that out-of-bounds exceptions are swallowed and \code{vl} is reduced accordingly.

All tests were successful when they ran, showing the emulator is correctly emulating the instructions, but in some cases testbenches weren't available.
The full set of test results is available in \cref{chap:fullresults:vectormemcpy}.

\begin{table}[h]
    \centering
    \begin{tabular}{lcc}
    \toprule
        Test Scheme & Harness & Compilers \\
        \midrule
        Unit Stride & Vanilla & All \\
        Strided & Vanilla & All \\
        Indexed & Vanilla & All \\
        Whole Register & Vanilla & All \\
        Fault-only-First & Vanilla & All \\
        
        Unit Stride (Masked) & Masked & All \\
        Bytemask Load & Masked & \code{llvm-15} only \\
        
        Unit Stride (Segmented) & Segmented & All \\

        Fault-only-First Boundary & - & All \\
         \bottomrule
    \end{tabular}
    \caption{\code{vector\_memcpy} test schemes and harnesses}
    \label{tab:vectormemcpyschemes}
\end{table}


\subsubsection{Compiler differences}\label{chap:eval:subsec:compilerdifferences}
While most compilers support all memory access archetypes, there are a few notable exceptions.
GCC has the most: there is no support for fractional LMUL or bytemask accesses, the intrinsics for segmented accesses are named differently, and fault-only-first intrinsics emit incorrect instructions\footnote{On GCC, fault-only-first intrinsics seem to emit \code{vsetvli}.}.
GCC RVV support has been deprioritized in favor of LLVM\footnote{\url{https://github.com/riscv-collab/riscv-gcc/issues/320}}, so the rough edges make sense.
LLVM-13-based compilers (including CHERI-Clang) support all specified archetypes except bytemask accesses.
CHERI-Clang doesn't support intrinsics, but all inline assembly support is intact.
Support for bytemask accesses is only available in LLVM-14 and up.

\subsection{\code{vector\_memcpy\_pointers}}
\code{vector\_memcpy\_pointers} tests the behaviour of \code{memcpy} with capabilities-in-vectors, by copying an array of data structures that hold pointers to static data.
On CHERI platforms, even in Integer mode, capability pointers are used and copied.
The first test simply copies the data and tests that all the copied pointers still work, which succeeds on all compilers/architectures.
The second test is CHERI-exclusive, and invalidates all pointers during the copy process by performing integer arithmetic on the vector registers.
The copied pointers are examined to make sure their tag bits are all zeroed, and this test succeeds on both CHERI configurations.

\begin{table}[h]
    \centering
    \CatchFileDef{\tablevecmemcpypointers}{1_50Evaluation/data/vector_memcpy_pointers_rows}{}
    \begin{tabular}{rcccccc}
    \tablevecmemcpypointers
    \end{tabular}
    \caption{\code{vector\_memcpy\_pointers} results}\label{tab:fullresults:vectormemcpyptrs}
\end{table}

\subsection{Summary}
All tests passed where available, and all tests were available on at least one compiler.
This shows the emulator is correctly executing vector instructions, and that it is possible to correctly \code{memcpy} capabilties in vector registers.

\end{document}