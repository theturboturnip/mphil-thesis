TODOs
1
thesis.tex- My acknowledgements ...
2
1_10Introduction/content.tex- nine
3
1_10Introduction/content.tex- fill out this para more, have an actual end sentence
4
1_20Background/sub30_rvv_model.tex- examples
5
1_20Background/sub35_rvv_memory.tex- Make thinner
6
1_20Background/sub50_cheri.tex- add diagram from TR-941?
7
1_20Background/sub50_cheri.tex- diagram for split/merged register file?
8
1_20Background/sub50_cheri.tex- is there rationale for that documented somewhere?
9
1_25EmulationInvestigation/sub10_emu_cheri.tex- table of relevant structures/functions?
10
1_25EmulationInvestigation/sub10_emu_cheri.tex- C code wasn't documented, Rust will be
11
1_25EmulationInvestigation/sub10_emu_cheri.tex- move markdown documentation into rust :)
12
1_25EmulationInvestigation/sub10_emu_cheri.tex- documentation should be made available somewhere
13
1_25EmulationInvestigation/sub10_emu_cheri.tex- diagram
14
1_25EmulationInvestigation/sub10_emu_cheri.tex- show the program flow for using modules
15
1_25EmulationInvestigation/content.tex- I wrote a type-safe wrapper class for capabilities, which either represented a valid capability or raw data, unlike the C library which represents a tagged/untagged capability. I should mention that here
16
1_25EmulationInvestigation/sub20_emu_vec.tex- short definition of provenance
17
1_25EmulationInvestigation/sub20_emu_vec.tex- diagram of floating point ld/st vs. vector ld/st
18
1_25EmulationInvestigation/sub20_emu_vec.tex- Decision tree for operation decoding
19
1_25EmulationInvestigation/sub20_emu_vec.tex- appendix XYZ
20
1_25EmulationInvestigation/sub30_fast_path.tex- fast-path could be split up? i.e. for LMUL = 8, could execute a fast-path for each register in the group rather than all 8 at once
21
1_25EmulationInvestigation/sub30_fast_path.tex- if an address range is calculated then: if capability contains it: SUCCESS else if it was wide or FoF: Likely-Failure else: FAILURE
22
1_25EmulationInvestigation/sub30_fast_path.tex- if an address range isn't calculated: Unchecked
23
1_25EmulationInvestigation/sub30_fast_path.tex- Put the above into an algorithm format
24
1_25EmulationInvestigation/sub30_fast_path.tex- iterating over elements may still be more energy-efficient than doing individual capability checks?
25
1_25EmulationInvestigation/sub30_fast_path.tex- Note that the equation is a simplification of strided for \code {stride = nf * eew}
26
1_25EmulationInvestigation/sub50_hyp.tex- Rewrite this as an energy equation? e.g. proportion of success * energy consumed by fast path etc.
27
1_25EmulationInvestigation/sub50_hyp.tex- This hypothesis probably needs a summary
28
1_30Software/content.tex- evaluation
29
1_30Software/content.tex- Figure page showing generated ASM for increment loop - see godbolt links MD
30
1_30Software/content.tex- example based on \url {https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/master/examples/rvv_memcpy.c}
31
1_30Software/content.tex- Hammer home that intrinsics aren't reusable across instruction sets? e.g. AVX intrinsics don't work with RISC-V
32
1_30Software/content.tex- example
33
1_30Software/content.tex- the previous sentence kinda sucks at getting the point across. Using a constraint forces the compiler to move the value into a register/memory
34
1_30Software/content.tex- example
35
1_30Software/content.tex- example
36
1_30Software/content.tex- example of CHERI-agnostic inline assembly
37
1_30Software/content.tex- Beautify this table
38
1_30Software/content.tex- appendix based on \url {https://godbolt.org/z/zoWh9jq3o}
39
1_30Software/content.tex- Appendix on how this was done?
40
1_30Software/content.tex- Example
41
1_30Software/content.tex- example
42
1_30Software/content.tex- example of error message?
43
1_30Software/content.tex- Appendix which covers what I know so far about this problem?
44
1_30Software/content.tex- segue into saving registers on stack doesn't make sense - doesn't explain why someone would want to
45
1_30Software/content.tex- Example https://godbolt.org/z/KPTW7rcvY
46
1_30Software/content.tex- Note: Arm Language C extensions https://developer.arm.com/documentation/100987/0000/ defines the concept of a sizeless type, which may be stored on the stack. Would be a good base for RVV?
47
1_30Software/content.tex- LLVM IR pass is investigated in TR-949 \$3.8.2, worth noting somewhere
