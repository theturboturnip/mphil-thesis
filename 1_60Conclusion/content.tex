\documentclass[../thesis]{subfiles}
\begin{document}

\chapter{Conclusion}
In this project we have built a new RISC-V emulator supporting one possible fusion of CHERI and RVV (\cref{chap:hardware}), explored the impact on the software stack by compiling and running test programs (\cref{chap:software,chap:eval}), and extended the RVV instruction set/vector model to store capabilities in vectors (\cref{chap:capinvec}).
On top of this substantial implementation effort, we have presented conclusions to a set of hypotheses (\cref{tab:hypotheses}) proving the general viability of adding scalable vector models to CHERI processsors.

\cref{hyp:hw_cap_as_vec_mem_ref} proved the most essential point, that a blanket replacement of all memory references with capabilities in all RVV instructions is valid.
\cref{hyp:hw_cap_bounds_checks_amortized} then alleviated performance concerns by showing it was possible to combine the required capability checks for all vector accesses, amortizing the overall cost of checking, although with varying practical benefit.

On the software side \cref{hyp:sw_vec_legacy,hyp:sw_pure_compat} showed that (in theory) non-CHERI vectorized code could be run on CHERI systems, and could also be recompiled for pure-capability execution with no source code changes, but that CHERI-Clang's current state adds some practical limitations.
\cref{hyp:sw_stack_vectors,hyp:sw_multiproc} address the pausing and resuming of vector code, particularly saving and restoring variable-length architectural state, concluding that it is entirely possible but will require software adjustments.

Through a limited investigation of capabilities-in-vectors, \cref{hyp:cap_in_vec_storage,hyp:cap_in_vec_load_store,hyp:cap_in_vec_manip} showed that a highly constrained implementation could enable a fully-functional vectorized \code{memcpy} without violating CHERI security principles.
It should be possible to extend the CHERI-RVV ISA with vector equivalents of existing CHERI scalar instructions, but I did not investigate this further.

Overall, it is clear that scalable vector models can be adapted to CHERI without significant loss of functionality.
While most of the hypotheses are general enough to cover other scalable models, e.g. Arm SVE, any differences from RVV's model will require careful examination.
Given the importance of vector processing to modern computing, and thus its importance to CHERI, I hope that this research and the software artifacts of this project (see \cref{appx:artifacts}) pave the way for future vector-enabled CHERI processor implementations.

\end{document}