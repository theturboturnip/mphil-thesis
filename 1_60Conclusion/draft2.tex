\documentclass[../thesis]{subfiles}
\begin{document}

\chapter{Conclusion}

This project proved the viability of integrating CHERI with scalable vector models by producing an example CHERI-RVV implementation.
This required both research effort in studying the related specifications (\cite{TR-951,specification-RVV-v1.0}), demonstrated in \cref{chap:background}, and a substantial implementation effort demonstrated in \cref{chap:hardware,chap:software,chap:capinvec}.
% During this project, we developed a large Rust and C codebase (9,120 lines of code) for a helper library (860 LoC), a RISC-V emulator (5,320 LoC), and a set of emulator test programs (2,940 LoC\footnote{\code{vector\_memcpy} uses an autogenerated test program, the generator is included but the extra 2,470 lines of generated code are not.}).
We produced four software artifacts: a Rust wrapper for the \code{cheri-compressed-cap} C library (900 lines of code), a RISC-V emulator supporting multiple architecture extensions (5,300 LoC), a fork of CHERI-Clang supporting RVV (400 changed LoC), and test programs for the emulator (3,000 LoC\footnote{This doesn't include automatically generated code.}).
% This includes the \code{vector\_memcpy} generator codebase but not the generated program.
% These are hosted online (see \cref{appx:artifacts}) and were submitted alongside this dissertation.
Developing these artifacts provided enough information to make conclusions for the initial hypotheses (\cref{tab:hypotheses}).

\section{Evaluating hypotheses}

\cref{hyp:hw_cap_as_vec_mem_ref} proved the most essential point, that a blanket replacement of all memory references with capabilities in all RVV instructions is valid.
\cref{hyp:hw_cap_bounds_checks_amortized} then alleviated performance concerns by showing it was possible to combine the required capability checks for all vector accesses, amortizing the overall cost of checking, although with varying practical benefit.

On the software side \cref{hyp:sw_vec_legacy,hyp:sw_pure_compat} showed that non-CHERI vectorized code could be run on CHERI systems, and even recompiled for pure-capability platforms with no source code changes, but that CHERI-Clang's current state adds some practical limitations.
We developed the \code{vector\_memcpy} test program to show that despite those limitations, it's possible to write correct CHERI-RVV code on current compilers.
% Despite those limitations, the \code{vector\_memcpy} testbench proves it's possible to write correct CHERI-RVV code on current compilers 
\cref{hyp:sw_stack_vectors,hyp:sw_multiproc} address the pausing and resuming of vector code, specifically saving and restoring variable-length architectural state, concluding that it is entirely possible but requires software adjustments.

Through a limited investigation of capabilities-in-vectors, \cref{hyp:cap_in_vec_storage,hyp:cap_in_vec_load_store,hyp:cap_in_vec_manip} showed that a highly constrained implementation could enable a fully-functional vectorized \code{memcpy}, as demonstrated in the \code{vector\_memcpy\_pointers} test program, without violating CHERI security principles.
It should be possible to extend the CHERI-RVV ISA with vector equivalents of existing CHERI scalar instructions, but we did not investigate this further.

Overall, it is clear that scalable vector models can be adapted to CHERI without significant loss of functionality.
Most of the hypotheses are general enough to cover other scalable models, e.g. Arm SVE, but any differences from RVV's model will require careful examination.
Given the importance of vector processing to modern computing, and thus its importance to CHERI, we hope that this research paves the way for future vector-enabled CHERI processors.

\section{Future work}
The stated purpose of this project was to enable future implementations of CHERI-RVV and CHERI Arm SVE.
We've shown this is feasible, and we believe our research is enough to create an initial CHERI-RVV specification, but both could benefit from more research.
% Now that we have shown this is feasible, building a useful specifications requires more work.
%are a few more steps required to nail down the specifics.

% Even though the 


% Firstly, we would suggest standardizing a definition of CHERI-RVV based on this dissertation.
% % This may not be the final version, e.g. some users may want extra instructions to facilitate hybrid execution mode like in  \cref{cheri_instructions}, but having one standard ensures tools and hardware can cooperate.
% % This specification could be implemented on the CHERI-RISC-V Sail model\footnote{\gitrepo{CTSRD-CHERI/sail-cheri-riscv}{https://github.com/CTSRD-CHERI/sail-cheri-riscv}}, which is used for formal verification
% CHERI-Clang then requires engineering work, as laid out in \cref{chap:software:sec:chericlangchanges}, and further work could add CHERI-RVV support to one of the preexisting CHERI-RISC-V cores\footnote{\url{https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html}}.
% % This standard should then evolve

The lowest-hanging fruit is capabilities-in-vectors.
% Capabilities-in-vectors has multiple areas ripe for further research.
% In terms of future theoretical work, capabilities-in-vectors is low-hanging fruit and has multiple potential research areas.
CHERI-specific processes, such as CHERIvoke \cite{xiaCHERIvokeCharacterisingPointer2019}, may benefit from more advanced vectorized capability manipulation. \todomark{reference CHERIvoke in ch4 intro}
Arm SVE includes addressing modes that use vector elements as memory references, and could benefit from dereferencing capabilities-in-vectors.
These could end up being simple additions, or could prove unfeasible.
% These may introduce extra complexity, as noted in \cref{chap:capinvec:eval}, and could prove unfeasible/too niche to include.
% \todomark{final sentence?}
% With these extra features, 
% Even without these extra features our research is a substantial step forward for vectors on CHERI, and 

Either way, we would suggest standardizing a definition of CHERI-RVV based on this dissertation.
% This version could evolve based on future research, but 
% This may not be the final version, e.g. some users may want extra instructions to facilitate hybrid execution mode like in  \cref{cheri_instructions}, but having one standard ensures tools and hardware can cooperate.
% This specification could be implemented on the CHERI-RISC-V Sail model\footnote{\gitrepo{CTSRD-CHERI/sail-cheri-riscv}{https://github.com/CTSRD-CHERI/sail-cheri-riscv}}, which is used for formal verification
This could then guide the engineering work for CHERI-Clang, as laid out in \cref{chap:software:sec:chericlangchanges}, and further work could add CHERI-RVV support to one of the preexisting CHERI-RISC-V cores\footnote{\url{https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html}}.
Implementing Arm SVE vectorization could 
% This standard should then evolve

% In either case, an initial CHERI-RVV specification should be constructed.
% This would guide engineering work on CHERI-Clang (see \cref{chap:software:sec:chericlangchanges}) and various CHERI-RISC-V implementations\footnote{\gitrepo{CTSRD-CHERI/sail-cheri-riscv}{https://github.com/CTSRD-CHERI/sail-cheri-riscv}, \url{https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html}}.
% % Implementing this specification in CHERI-Clang, 

% This is relevant for Arm SVE, as it includes addressing modes that use vector elements as memory references, and also to CHERI-specific operations such as CHERIvoke\cite{xiaCHERIvokeCharacterisingPointer2019} which may benefit from more advanced vectorized capability manipulation.
% \todomark{future work - implementation?}

\end{document}