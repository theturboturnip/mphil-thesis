\chapter{The CHERI-RVV software stack}
\todomark{Introduction}

\section{Compiling vector code}
Modern compilers provide many ways to generate vectorized code.
While this support is very advanced for well established vector models, like x86-64 AVX, newer vector models like RVV don't have as many options.
It can even be difficult to get the compiler to generate any vector instructions at all.
This section examines support across the Clang and GCC compilers for various vectorization methods on RVV.

\subsection{Automatic vectorization}
\todomark{Figure page showing generated ASM for increment loop - see godbolt links MD}
Compilers with auto-vectorization can automatically create vectorized code from a scalar program.
For example, a scalar loop over an array that increments each element could be converted to a vectorized loop that increments multiple elements at once.
Although this is simple in some cases, auto-vectorization can take significant effort and time to implement (for example, GCC started implementing it for x86 in 2003 and only turned on basic support in 2007 \todocite{https://gcc.gnu.org/projects/tree-ssa/vectorization.html}).
Currently there is no support for RVV auto-vectorization in Clang or GCC.
Both compilers have support for Arm SVE auto-vectorization, explored further in \cref{chap:soft:compiling:armsve}.

\subsection{Vector intrinsics}
\enquote{Intrinsics} are functions built in to a compiler that can invoke low-level functionality and instructions directly for a specific architecture.
When automatic vectorization is not available, intrinsics are the next best thing - they present a familiar high-level interface (function calls), that gives the programmer fine-grained control over which instructions to execute, typically providing an intrinsic for each vector instruction.
The compiler then handles low-level decisions like register allocation under the hood, and sometimes may provide extra functionality for ease of use.
%the compiler still allocates registers 

% A prime example is RVV's vector intrinsics\todocite{RISCVVectorIntrinsicsv0.1}, implemented in GCC~?\todocite{} and Clang~13+\todocite{}.
% All instructions that rely on the current vector length \code{vl} take it as an argument for their respective intrinsics.
% The programmer is strongly encouraged to use a \code{vsetvl} intrinsic to generate the length first, but could also pass the 
% which allow (and strongly suggest) the programmer to get the vector length with a \code{vsetvl} function, then pass it to an 

RVV has a comprehensive set of vector intrinsics\todocite{RISCVVectorIntrinsicsv0.1}, implemented in a special version of RISC-V~GCC~10.1\footnote{See \cref{appx:building_rvv_gcc_toolchain} to find and build this version.} and Clang~13 onwards.
With these, the general strip-mining loop is easy to construct:
\todomark{example based on \url{https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/master/examples/rvv_memcpy.c}}
\begin{enumerate}
    \item Use a \code{vsetvl} intrinsic to get the vector length for this iteration.
    \item Allocate vector registers by declaring variables with vector types (e.g. \code{vuint32m8_t} represents 8 registers worth of 32-bit unsigned integers).
    \item Pass the vector length to the computation/memory intrinsics, which operate on the vector variables.
\end{enumerate}

\todomark{Hammer home that intrinsics aren't reusable across instruction sets? e.g. AVX intrinsics don't work with RISC-V}

\subsection{Inline assembly}
If a compiler doesn't supply complete intrinsics, or if the programmer desires extremely fine-grained control, inline assembly may be used.
The programmer gives a string of handwritten assembly code to the compiler, which is parsed and directly inserted into the output code at that point.
The compiler still has to interpret the instruction and understand it correctly, but as long as it knows the instruction this method does not depend on any intrinsics being present (or functional\footnote{For example, CHERI-Clang could not compile code with vector intrinsics, so had to use inline assembly for all vector instructions.}).

Inline assembly can interact with C code and variables through a template syntax.
The programmer inserts a placeholder in the assembly code with a corresponding expression, noting how the expression is stored using a \enquote{constraint}.
For our purposes, constraints enforce that a value is either in a register or in memory (see \cref{tab:inline_asm_constraint}).
As an example, writing to a memory address stored in a variable could use a constraint \code{"m"(*addr)} - i.e. \enquote{the value pointed to by \code{addr} is stored in memory}. \todoref{Example} \todomark{the previous sentence kinda sucks at getting the point across. Using a constraint forces the compiler to move the value into a register/memory}

Using the constraint, the compiler determines how the expression's value is stored, and inserts a reference to it in the assembly string.
Because this is done before the assembly string is parsed, and isn't immediately type-checked against the assembly instruction, it can lead to some difficult errors.

Clang and GCC support inline assembly for RVV quite well, and even allows the intrinsic vector types to be referenced by assembly templates (thus making the compiler do register allocation instead of the programmer).
The only caveat is that \emph{memory} constraints are not supported by RVV memory accesses.
None of the vector memory access instructions support address offsets, unlike their scalar counterparts.
Clang always treats the \emph{memory} constraint as an offset access, even when that offset is zero, so it adds an offset to the assembly string \todoref{example}, making it invalid.
To get around this, one must use the pointer itself with a \emph{register} constraint - effectively saying \enquote{find the register this pointer is in, and use that as the base address for the memory access} \todoref{example}.
On CHERI platforms, because pointers must be stored in capability registers, the \emph{capability register} constraint must be used instead (see \todoref{CHERI-agnostic inline assembly}).

Broadly speaking, inline assembly supports more RVV instructions than intrinsics do.
It is used extensively in the testbench code for the evaluation (\todoref{evaluation}) alongside intrinsics where possible.

% the compiler determines where the value of the expression is/should be stored, and inserts a reference to that location in the assembly string.
% The programmer may also control where the expression is stored by setting a \enquote{constraint}.
% This is an extremely useful feature, particularly if 
% Because this is done before the assembly string is parsed, it can lead to some difficult-to-understand errors.

\begin{table}[]
    \centering
    \begin{tabular}{c|c}
       "="  & Output - the old value is overwritten. Can be combined with other constraints. \\
        "r" & Store in a register \\
        "vr" & Store in a vector register (RVV only) \\
        "C" & Store in a capability register (CHERI-Clang only) \\
        "m" & Store in memory \\
    \end{tabular}
    \caption{Inline assembly constraints \todocite{That one GCC manual page about inline asm constraints}}
    \label{tab:inline_asm_constraints}
    \todomark{Beautify this table}
\end{table}

\subsection{Compiler support summary}
\begin{tabular}{lll}
    \toprule
    Compiler & Required Arguments & Notes \\ 
    \midrule
    Clang/LLVM-13 & \code{-march=rv64gv0p10 -menable-experimental-extensions} & Supports intrinsics, inline assembly for RVV v0.1 \\
    Clang/LLVM-14+ & \code{-march=rv64gv} & Supports intrinsics, inline assembly for RVV v1.0 \\
    RISC-V GCC 10.1 & \code{-march=rv64g_v} & Requires special toolchain (see \cref{appx:building_rvv_gcc_toolchain}) and has incomplete support (see \todoref{bit from testing where we talk about GCC being iffy}) \\
    \bottomrule
\end{tabular}

\subsubsection{vs. Arm SVE}\label{chap:soft:compiling:armsve}
\todomark{Arm SVE has extensive auto-vectorization, RISC-V V does not.}
\todomark{Would it be easy to bring this auto-vectorization code to RISC-V V?}
\todomark{Arm SVE and RVV have comparable(?) intrinsics}
\todomark{Arm SVE and RVV have comparable(?) abilities, and can both achieve these through inline assembly?}
\todomark{Can you use Arm SVE intrinsic types with inline ASM?}

\section{Compiling vector code with CHERI-Clang}
\subsection{Making vector instructions take capabilities}
\subsection{Adapting vector intrinsics to CHERI}
\subsection{CHERI-agnostic inline assembly}
\subsection{Storing scalable vectors on-stack}

\section{Testing hypotheses}

\todomark{H-C: At machine level, yes - a program compiled for CHERI-RVV will have the exact same vector instruction encodings as a non-CHERI RVV.
Practically:
Yes under auto-vectorization once added, Yes under vector intrinsics IFF it gets ported, Yes under inline-assembly WITH a simple macro}

\todomark{H-D: Yes IFF vectors can be stored on the stack. May require a dynamic stack bounds calculation based on VLEN.}