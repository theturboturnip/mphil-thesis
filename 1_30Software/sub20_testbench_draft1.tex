\section{Developing the testbench}\label{chap:software:sec:testbench}

\subsection{Vectorized memcpy}

\subsubsection{Strip-mining paradigm?}

\subsection{Emitting vector instructions}
Modern compilers provide many ways to generate vectorized code from a C program.
While this support is very advanced for well established vector models, like x86-64 AVX, newer vector models like RVV don't have as many options.
It can even be difficult to get the compiler to generate any vector instructions at all.
This subsection examines compiler support for various vectorization methods on RVV.

\todomark{provide full reproductions of godbolt experiments in appendix?}

\subsubsection{Auto-vectorization}
Compilers with auto-vectorization can automatically create vectorized code from a scalar program.
For example, a scalar loop over an array that increments each element could easily be converted to a vectorized loop that increments multiple elements at once.



\subsubsection{Intrinsics}
\subsubsection{Inline ASM}
% CHERI-Clang has undocumented "C" constraint

\subsection{CHERI-Clang issues}
\subsubsection{Using CHERI-Clang from scratch}
% i.e. the things we had to do because CHERIbuild wasn't setting the arguments for us
\subsubsection{Updating RVV instructions to use capabilities}
\subsubsection{Experiments with ASM wrappers}
% Tried ASM wrappers, didn't work because can't return/pass vectors as args (cite ABI)
% Therefore moved to ASM 
\subsubsection{Allocating vectors on the stack}
% ASM wrappers also exposed that CHERI fails to something
\subsubsection{Other}
% note difference with CJALR/JALR?


\subsection{Final testbench structure}

\subsection{Results}