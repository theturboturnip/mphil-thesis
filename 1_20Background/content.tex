\chapter{Background}
% PLAN: 4k words

This chapter describes CHERI (\cref{chap:bg:sec:cheri}) and RVV (\cref{chap:bg:sec:rvv}) to the detail required to understand the rest of the dissertation.
Both are described because this dissertation caters to multiple audiences: those who already understand CHERI, but are less familiar with vectors; and those already familiar with vector hardware but not with CHERI.
The final section describes two other vector models in a little more detail.
They are both proprietary, so we cannot learn from their hardware, but they are useful for contextualizing the software side of things.


\section{CHERI}\label{chap:bg:sec:cheri}
% Concept of a capability
In CHERI, addresses/pointers are replaced with capabilities: unforgeable tokens that provide \emph{specific kinds of access} to an \emph{address} within a \emph{range of memory}.
The above statement is enough to understand what capabilities contain\footnote{This is a slight simplification. For the purposes of vector memory accesses the \emph{otype} of a capability can be ignored, as any type other than \code{UNSEALED} cannot be dereferenced anyway.}:
\begin{itemize}
    \item Permission bits, to restrict access
    \item The \emph{cursor}, i.e. the address it currently points to
    \item The \emph{bounds}, i.e. the range of addresses this capability could point to
\end{itemize}
A great deal of work has gone into compressing capabilities down into a reasonable size (see \todocite{woodruffCHERIConcentratePractical2019}, \todoref{diagram from TR-941?}), and using the magic of floating-point all of this data has been reduced to just 2x the architectural register size.
For example, on 64-bit RISC-V a standard capability is 128-bits long.
The rest of this dissertation assumes capabilities are 128-bits long for simplicity.

In order to keep track of what is and isn't a capability, registers and memory are both tagged.
Each 128-bit register and each aligned 128-bit region of memory has an associated tag bit, which denotes if its data encodes a valid capability\footnote{This has the side-effect that capabilities must be 128-bit aligned in memory.}.
If any non-capability data is written to any part of the region, the tag bit is zeroed out.
\todomark{Can you have a capability with tag=1, but the cursor is outside the bounds?}
As above, significant work has gone into the implementation to reduce the DRAM overhead of this method (see \todocite{joannouEfficientTaggedMemory2017} for an example).


\todomark{Explain the three properties of a capability from davisCheriABIEnforcingValid2019?}

\todomark{Explain CHERI capability instructions vs. legacy instructions that use DDC}

% Hybrid vs. Pure-Capability code

\subsection{CHERI RISC-V}
Integer vs. Capability mode in hardware?

\section{RVV}\label{chap:bg:sec:rvv}

\subsection{Scalable vs. fixed-size vectors}
Many vector implementations (Intel SSE/AVX, Arm's Advanced SIMD and Neon) use fixed-length vectors - e.g. 128-bit vectors which a program interprets as four 32-bit elements.
As the industry's desire for parallelism grew, new implementations had to be designed with longer vectors of more elements.
For example, Intel SSE/SSE2 (both 128-bit) was succeeded by AVX (128 and 256-bit), then AVX2 (entirely 256-bit), then AVX-512 (512-bit).
Programs built for one extension, and hence designed for a specific vector size, could not automatically take advantage of longer vectors.

Scalable vectors address this by not specifying the vector length, and instead calculating it on the fly.
Instead of hardcoding \enquote{this loop iteration uses a single vector of four 32-bit elements}, the program has to ask \enquote{how many 32-bit elements will this iteration use?}.
This gives hardware designers more freedom, letting them select a suitable hardware vector length for their power/timing targets, while guaranteeing consistent execution of programs on arbitrarily-sized vectors.
\todomark{move the above}


\subsection{General vector model}
e.g. LMUL, vstart, vsetvli, masking

\subsection{Access types}
unit/strided,
indexed,
fof,
bytemask,
wholeregister.

\subsection{Interaction with exceptions}

\subsection{Implementations}

\section{Other Vector Models}
\subsection{Arm SVE}
\subsection{Intel SSE/AVX}